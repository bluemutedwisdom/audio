// Generated by CoffeeScript 1.6.1
(function() {

  jQuery(function($) {
    var animationStyle, beatInterval, bpm, callback, createMarker, init, markerAnimationDelay, markers, matrix, steps, target, width;
    target = new google.maps.LatLng(59.3313, 18.071);
    markers = [];
    matrix = [];
    steps = 16;
    width = $('.container').width();
    bpm = 120;
    markerAnimationDelay = 300;
    animationStyle = google.maps.Animation.DROP;
    beatInterval = 1 / (bpm / 60) * 1000;
    init = function() {
      var AudioPlayer, bounceMarker, clearMatrix, context, event, getCellPosition, highlightCell, i, j, map, mapOptions, overlay, request, row, service, turnOnCell, _i, _j, _k, _len, _ref, _ref1, _ref2;
      $('#showOverlay').click(function() {
        if (this.checked) {
          return $('#overlay').fadeIn();
        } else {
          return $('#overlay').fadeOut();
        }
      });
      $('#animationStyle').change(function(v) {
        var markerAniamtionDelay;
        animationStyle = google.maps.Animation[this.value];
        if (this.value === google.maps.Animation.DROP) {
          return markerAnimationDelay = 400;
        } else {
          return markerAniamtionDelay = 0;
        }
      });
      mapOptions = {
        center: target,
        zoom: 15,
        streetViewControl: false,
        panControl: false,
        mapTypeId: google.maps.MapTypeId.ROADMAP,
        zoomControlOptions: {
          style: google.maps.ZoomControlStyle.SMALL
        },
        mapTypeControlOptions: {
          mapTypeIds: [google.maps.MapTypeId.ROADMAP, 'map_style']
        }
      };
      map = window.map = new google.maps.Map(document.getElementById("map"), mapOptions);
      request = {
        location: target,
        radius: 400
      };
      service = new google.maps.places.PlacesService(map);
      service.nearbySearch(request, callback);
      overlay = new google.maps.OverlayView();
      overlay.draw = function() {};
      overlay.setMap(map);
      for (i = _i = 0, _ref = steps - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        row = document.createElement('tr');
        $('#matrix').prepend(row);
        for (j = _j = 0, _ref1 = steps - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          row.appendChild(document.createElement('td'));
        }
      }
      getCellPosition = function(x, y) {
        var col;
        row = Math.floor(x / width * steps);
        col = Math.floor(y / width * steps);
        return [row, col];
      };
      clearMatrix = function() {
        matrix = [];
        return $('table td').removeClass('on');
      };
      turnOnCell = function(row, col, marker) {
        var cell, _base;
        matrix[col] || (matrix[col] = {});
        cell = (_base = matrix[col])[row] || (_base[row] = {});
        cell.markers || (cell.markers = []);
        cell.markers.push(marker);
        cell.node = $($('#matrix')[0].rows[row].cells[col]);
        return cell.node.addClass('on');
      };
      window.updateMatrix = function() {
        var col, marker, p, pos, proj, _k, _len, _ref2;
        clearMatrix();
        proj = overlay.getProjection();
        for (_k = 0, _len = markers.length; _k < _len; _k++) {
          marker = markers[_k];
          pos = marker.getPosition();
          p = proj.fromLatLngToContainerPixel(pos);
          _ref2 = getCellPosition(p.y, p.x), row = _ref2[0], col = _ref2[1];
          if (row >= 0 && row < steps && col >= 0 && col < steps) {
            turnOnCell(row, col, marker);
          }
        }
        return matrix;
      };
      _ref2 = ['bounds_changed'];
      for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
        event = _ref2[_k];
        google.maps.event.addListener(map, event, function() {
          return updateMatrix();
        });
      }
      highlightCell = function(node, delay) {
        if (delay == null) {
          delay = 0;
        }
        return setTimeout(function() {
          node.addClass('active');
          return setTimeout(function() {
            return node.removeClass('active');
          }, 500);
        }, delay);
      };
      bounceMarker = function(marker) {
        marker.setAnimation(animationStyle);
        return setTimeout(function() {
          return marker.setAnimation(google.maps.Animation.NONE);
        }, 700);
      };
      this.start = function() {
        var currentStep;
        clearInterval(this.interval);
        currentStep = 0;
        return this.interval = setInterval(function() {
          var activeCells, cell, marker, _l, _len1, _ref3;
          if (activeCells = matrix[currentStep]) {
            for (row in activeCells) {
              cell = activeCells[row];
              _ref3 = cell.markers;
              for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
                marker = _ref3[_l];
                bounceMarker(marker);
              }
              highlightCell(cell.node, markerAnimationDelay);
              this.audioPlayer.play(row, markerAnimationDelay);
            }
          }
          currentStep++;
          if (currentStep >= steps) {
            return currentStep = 0;
          }
        }, beatInterval * 0.25);
      };
      context = new webkitAudioContext();
      AudioPlayer = (function() {

        function AudioPlayer() {
          var bufferLoader, paths, _l,
            _this = this;
          this.compressor = context.createDynamicsCompressor();
          this.compressor.connect(context.destination);
          paths = [];
          for (i = _l = 1; _l <= 16; i = ++_l) {
            paths.push("samples/woody/woody_" + i + ".ogg");
          }
          bufferLoader = new BufferLoader(context, paths, function(bufferList) {
            _this.bufferList = bufferList;
          });
          bufferLoader.load();
        }

        AudioPlayer.prototype.play = function(index, delay) {
          var note;
          if (delay == null) {
            delay = 0;
          }
          note = context.createBufferSource();
          note.buffer = this.bufferList[index];
          note.connect(this.compressor);
          return setTimeout(function() {
            return note.noteOn(0);
          }, delay);
        };

        return AudioPlayer;

      })();
      this.audioPlayer = window.audioPlayer = new AudioPlayer;
      return this.start();
    };
    callback = function(results, status) {
      var attrs, index;
      if (status === google.maps.places.PlacesServiceStatus.OK) {
        for (index in results) {
          attrs = results[index];
          createMarker(results[index]);
        }
      }
      return updateMatrix();
    };
    createMarker = function(place) {
      var marker;
      marker = new google.maps.Marker({
        map: map,
        title: place.types.join('-'),
        position: place.geometry.location
      });
      return markers.push(marker);
    };
    return init();
  });

}).call(this);
