// Generated by CoffeeScript 1.6.1
(function() {

  jQuery(function($) {
    var animationStyle, beatInterval, bpm, callback, coords, createMarker, currentDataset, init, markers, matrix, options, steps, target, width;
    coords = (hash.get('coords') || "").split(',');
    target = new google.maps.LatLng(coords[0] || 1.322221, coords[1] || 103.826531);
    markers = [];
    matrix = [];
    steps = 16;
    width = $('.container').width();
    bpm = 120;
    window.markerAnimationDelay = 300;
    animationStyle = google.maps.Animation.DROP;
    currentDataset = hash.get('dataset') || 'restaurant';
    options = {
      sequencer: hash.get('sequencer') || 'off',
      tempo: hash.get('tempo') || '120',
      instrument: hash.get('instrument') || 'wood',
      animation: hash.get('animation') || 'drop'
    };
    beatInterval = 1 / (bpm / 60) * 1000;
    init = function() {
      var AudioPlayer, bounceMarker, clearMatrix, context, event, generateURL, getCellPosition, highlightCell, i, j, map, mapOptions, overlay, row, turnOnCell, updateOptions, _i, _j, _k, _len, _ref, _ref1, _ref2,
        _this = this;
      generateURL = function() {
        var column, index, li, text, type, _i, _len, _results;
        coords = map.getCenter().toUrlValue();
        hash.add({
          coords: coords
        });
        hash.add({
          dataset: currentDataset
        });
        hash.add(options);
        $("#datalist ul").empty();
        _results = [];
        for (index = _i = 0, _len = datatypes.length; _i < _len; index = ++_i) {
          type = datatypes[index];
          li = document.createElement('li');
          li.className = 'datatype';
          if (Array.isArray(type)) {
            text = type[1];
            $(li).attr('data-type', type[0]);
          } else {
            $(li).attr('data-type', type);
            text = "" + type + "s";
          }
          text = text.split('_').join(' ');
          li.innerHTML = text;
          column = Math.floor(index / 30);
          _results.push($("#datalist .column" + column).append(li));
        }
        return _results;
      };
      $('body').click(function(event) {
        if (event.target.id !== 'currentDataset' && !$(event.target).closest('#datalist').length) {
          return $('#datalist').fadeOut('fast');
        }
      });
      $('#currentDataset').click(function(event) {
        return $('#datalist').fadeIn('fast');
      });
      $('#datalist').on('click', '.datatype', function(event) {
        $('#currentDataset').text($(event.target).text());
        $('#datalist').fadeOut('fast');
        currentDataset = $(event.target).data('type');
        generateURL();
        return _this.search();
      });
      updateOptions = function() {
        var el, format, key, markerAnimationDelay, newInterval, value;
        if (options.sequencer === 'on') {
          $('#overlay').fadeIn();
        } else {
          $('#overlay').fadeOut();
        }
        if ((newInterval = 1 / (options.tempo / 60) * 1000) !== beatInterval) {
          beatInterval = newInterval;
          this.start();
        }
        animationStyle = google.maps.Animation[options.animation.toUpperCase()];
        if (animationStyle === google.maps.Animation.DROP) {
          markerAnimationDelay = 300;
        } else {
          markerAnimationDelay = 0;
        }
        for (key in options) {
          value = options[key];
          el = $("#navigation [data-property=" + key + "]");
          el.find('.currentState').text(value);
        }
        format = $("#navigation [data-name=" + options.instrument + "]").data('format');
        this.audioPlayer.selectInstrument(options.instrument, format);
        return generateURL();
      };
      $('.subitem').click(function() {
        var parent, property, value;
        value = $(this).text();
        parent = $(this).parents('.item');
        property = parent.data('property');
        options[property] = value.toLowerCase();
        return updateOptions();
      });
      mapOptions = {
        center: target,
        zoom: 13,
        streetViewControl: false,
        panControl: false,
        mapTypeId: google.maps.MapTypeId.ROADMAP,
        zoomControlOptions: {
          style: google.maps.ZoomControlStyle.SMALL
        },
        mapTypeControlOptions: {
          mapTypeIds: [google.maps.MapTypeId.ROADMAP, 'map_style']
        }
      };
      map = window.map = new google.maps.Map(document.getElementById("map"), mapOptions);
      this.search = function() {
        var marker, request, service, _i, _len;
        for (_i = 0, _len = markers.length; _i < _len; _i++) {
          marker = markers[_i];
          marker.setMap(null);
        }
        markers = [];
        request = {
          location: target,
          radius: 4000,
          types: [currentDataset]
        };
        service = new google.maps.places.PlacesService(map);
        return service.nearbySearch(request, callback);
      };
      overlay = new google.maps.OverlayView();
      overlay.draw = function() {};
      overlay.setMap(map);
      for (i = _i = 0, _ref = steps - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        row = document.createElement('tr');
        $('#matrix').prepend(row);
        for (j = _j = 0, _ref1 = steps - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          row.appendChild(document.createElement('td'));
        }
      }
      getCellPosition = function(x, y) {
        var col;
        row = Math.floor(x / width * steps);
        col = Math.floor(y / width * steps);
        return [row, col];
      };
      clearMatrix = function() {
        matrix = [];
        return $('table td').removeClass('on');
      };
      turnOnCell = function(row, col, marker) {
        var cell, _base;
        matrix[col] || (matrix[col] = {});
        cell = (_base = matrix[col])[row] || (_base[row] = {});
        cell.markers || (cell.markers = []);
        cell.markers.push(marker);
        cell.node = $($('#matrix')[0].rows[row].cells[col]);
        return cell.node.addClass('on');
      };
      window.updateMatrix = function() {
        var col, marker, p, pos, proj, _k, _len, _ref2;
        clearMatrix();
        proj = overlay.getProjection();
        for (_k = 0, _len = markers.length; _k < _len; _k++) {
          marker = markers[_k];
          pos = marker.getPosition();
          p = proj.fromLatLngToContainerPixel(pos);
          _ref2 = getCellPosition(p.y, p.x), row = _ref2[0], col = _ref2[1];
          if (row >= 0 && row < steps && col >= 0 && col < steps) {
            turnOnCell(row, col, marker);
          }
        }
        return matrix;
      };
      _ref2 = ['bounds_changed'];
      for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
        event = _ref2[_k];
        google.maps.event.addListener(map, event, function() {
          return updateMatrix();
        });
      }
      google.maps.event.addListener(map, 'idle', function() {
        return generateURL();
      });
      highlightCell = function(node, delay) {
        if (delay == null) {
          delay = 0;
        }
        return setTimeout(function() {
          node.addClass('active');
          return setTimeout(function() {
            return node.removeClass('active');
          }, 100);
        }, delay);
      };
      bounceMarker = function(marker) {
        marker.setAnimation(animationStyle);
        return setTimeout(function() {
          return marker.setAnimation(google.maps.Animation);
        }, 700);
      };
      this.start = function() {
        var currentStep;
        clearInterval(this.interval);
        currentStep = 0;
        return this.interval = setInterval(function() {
          var activeCells, cell, marker, _l, _len1, _ref3;
          if (activeCells = matrix[currentStep]) {
            for (row in activeCells) {
              cell = activeCells[row];
              _ref3 = cell.markers;
              for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
                marker = _ref3[_l];
                bounceMarker(marker);
              }
              highlightCell(cell.node, markerAnimationDelay);
              this.audioPlayer.play(row, markerAnimationDelay);
            }
          }
          currentStep++;
          if (currentStep >= steps) {
            return currentStep = 0;
          }
        }, beatInterval * 0.25);
      };
      context = new webkitAudioContext();
      AudioPlayer = (function() {

        function AudioPlayer() {
          this.instruments = {};
          this.compressor = context.createDynamicsCompressor();
          this.compressor.connect(context.destination);
        }

        AudioPlayer.prototype.selectInstrument = function(name, format) {
          var bufferLoader, paths, _l,
            _this = this;
          if (!(this.bufferList = this.instruments[name])) {
            paths = [];
            for (i = _l = 1; _l <= 16; i = ++_l) {
              paths.push("samples/" + name + "/" + name + i + "." + format);
            }
            bufferLoader = new BufferLoader(context, paths, function(bufferList) {
              _this.bufferList = bufferList;
              return _this.instruments[name] = _this.bufferList;
            });
            return bufferLoader.load();
          }
        };

        AudioPlayer.prototype.play = function(index, delay) {
          var note;
          if (delay == null) {
            delay = 0;
          }
          if (!this.bufferList) {
            return;
          }
          note = context.createBufferSource();
          note.buffer = this.bufferList[index];
          note.connect(this.compressor);
          return setTimeout(function() {
            return note.noteOn(0);
          }, delay);
        };

        return AudioPlayer;

      })();
      this.search();
      this.audioPlayer = new AudioPlayer;
      this.start();
      return updateOptions();
    };
    callback = function(results, status) {
      var attrs, index;
      if (status === google.maps.places.PlacesServiceStatus.OK) {
        for (index in results) {
          attrs = results[index];
          createMarker(results[index]);
        }
      }
      return updateMatrix();
    };
    createMarker = function(place) {
      var marker;
      marker = new google.maps.Marker({
        map: map,
        title: place.types.join('-'),
        position: place.geometry.location
      });
      return markers.push(marker);
    };
    return init();
  });

}).call(this);
